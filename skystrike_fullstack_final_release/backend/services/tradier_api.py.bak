# services/tradier_api.py

import os
import requests
from datetime import datetime, timedelta

# Determine paper vs. live endpoint
MODE = os.getenv("TRADIER_MODE", "paper").lower()
if MODE == "paper":
    TRADIER_BASE_URL = "https://sandbox.tradier.com/v1"
else:
    TRADIER_BASE_URL = "https://api.tradier.com/v1"

TRADIER_TOKEN      = os.getenv(f"TRADIER_{MODE.upper()}_ACCESS_TOKEN")
TRADIER_ACCOUNT_ID = os.getenv(f"TRADIER_{MODE.upper()}_ACCOUNT_ID")

# Timeouts for different calls
REQUEST_TIMEOUT = {
    "quote": 5,
    "order": 10,
}

HEADERS = {
    "Authorization": f"Bearer {TRADIER_TOKEN}",
    "Accept":        "application/json",
}


def calculate_expiration(dte: int) -> str:
    """
    Convert a DTE value into an ISO date string (YYYY-MM-DD),
    treating 0 as 'next trading day' and skipping weekends.
    """
    days = dte if dte > 0 else 1
    exp_date = datetime.utcnow().date() + timedelta(days=days)
    while exp_date.weekday() >= 5:  # 5 = Saturday, 6 = Sunday
        exp_date += timedelta(days=1)
    return exp_date.isoformat()


def get_quote(symbol: str) -> dict:
    """Fetch the latest underlying quote for a symbol."""
    resp = requests.get(
        f"{TRADIER_BASE_URL}/markets/quotes",
        params={"symbols": symbol},
        headers=HEADERS,
        timeout=REQUEST_TIMEOUT["quote"],
    )
    resp.raise_for_status()
    return resp.json()["quotes"]["quote"]


def get_expirations(symbol: str) -> list[str]:
    """Return available option expiration dates (ISO) for the symbol."""
    resp = requests.get(
        f"{TRADIER_BASE_URL}/markets/options/expirations",
        params={"symbol": symbol},
        headers=HEADERS,
        timeout=REQUEST_TIMEOUT["quote"],
    )
    resp.raise_for_status()
    return resp.json()["expirations"]["date"]


def get_open_pnl() -> dict:
    """Fetch all open positions (for dashboard health)."""
    resp = requests.get(
        f"{TRADIER_BASE_URL}/accounts/{TRADIER_ACCOUNT_ID}/positions",
        headers=HEADERS,
        timeout=REQUEST_TIMEOUT["quote"],
    )
    resp.raise_for_status()
    return resp.json()


def fetch_order_status(bot_name: str) -> dict:
    """Fetch the list of all orders for the account."""
    resp = requests.get(
        f"{TRADIER_BASE_URL}/accounts/{TRADIER_ACCOUNT_ID}/orders",
        headers=HEADERS,
        timeout=REQUEST_TIMEOUT["quote"],
    )
    resp.raise_for_status()
    return resp.json()


def get_open_orders() -> dict:
    """Fetch only the open orders for the account."""
    resp = requests.get(
        f"{TRADIER_BASE_URL}/accounts/{TRADIER_ACCOUNT_ID}/orders",
        params={"state": "open"},
        headers=HEADERS,
        timeout=REQUEST_TIMEOUT["quote"],
    )
    resp.raise_for_status()
    return resp.json()


def get_option_chain(symbol: str, expiration: str) -> dict:
    """
    Fetch the option chain for a given symbol + ISO expiration.
    Returns the 'options' dict or None if not available.
    """
    resp = requests.get(
        f"{TRADIER_BASE_URL}/markets/options/chains",
        params={"symbol": symbol, "expiration": expiration},
        headers=HEADERS,
        timeout=REQUEST_TIMEOUT["quote"],
    )
    resp.raise_for_status()
    return resp.json().get("options")


def place_iron_condor(ticker: str, contracts: int, dte: int) -> dict:
    """
    Build and submit a 4-leg Iron Condor via Tradier's multileg API.
    """
    # 1) Compute ISO expiration and fetch chain
    exp = calculate_expiration(dte)
    chain = get_option_chain(ticker, exp)
    if not chain:
        raise RuntimeError(f"No option chain for {ticker} exp={exp}")

    # 2) Get underlying price
    q = get_quote(ticker)
    last_price = float(q.get("last", q.get("close", 0.0)))

    # 3) Define strikes 5 points apart around ATM
    width = 5.0
    atm = round(last_price / width) * width
    legs = {
        0: (atm + width,    "C", "sell_to_open"),
        1: (atm + 2*width,  "C", "buy_to_open"),
        2: (atm - width,    "P", "sell_to_open"),
        3: (atm - 2*width,  "P", "buy_to_open"),
    }

    # 4) Build form-encoded order payload
    exp_str = exp.replace("-", "")
    data = {"type": "multileg", "symbol": ticker, "duration": "day"}
    for i, (strike, right, side) in legs.items():
        s = f"{int(strike * 1000):08d}"
        data[f"option_symbol[{i}]"] = f"{ticker}{exp_str}{right}{s}"
        data[f"side[{i}]"]           = side
        data[f"quantity[{i}]"]       = contracts

    headers = {**HEADERS, "Content-Type": "application/x-www-form-urlencoded"}
    resp = requests.post(
        f"{TRADIER_BASE_URL}/accounts/{TRADIER_ACCOUNT_ID}/orders",
        headers=headers,
        data=data,
        timeout=REQUEST_TIMEOUT["order"],
    )

    # Debug logs
    print("[TRADIER ORDER REQUEST DATA]", data)
    print("[TRADIER RESPONSE]", resp.status_code, resp.text)

    resp.raise_for_status()
    return resp.json()


# Alias for your generic bot framework
place_order = place_iron_condor
