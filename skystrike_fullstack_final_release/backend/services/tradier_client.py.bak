import os
from dotenv import load_dotenv
import httpx
from typing import List, Dict, Any, Optional

# Load .env
load_dotenv()

# Determine paper vs. live mode
MODE = os.getenv("TRADIER_MODE", "paper").strip().lower()
if MODE not in ("paper", "live"):
    raise RuntimeError(f"Invalid TRADIER_MODE: {MODE}")

BASE_URL = "https://sandbox.tradier.com/v1" if MODE == "paper" else "https://api.tradier.com/v1"
TOKEN    = os.getenv(f"TRADIER_{MODE.upper()}_ACCESS_TOKEN")
ACCOUNT  = os.getenv(f"TRADIER_{MODE.upper()}_ACCOUNT_ID")

if not TOKEN:
    raise RuntimeError(f"Missing TRADIER_{MODE.upper()}_ACCESS_TOKEN")
if not ACCOUNT:
    raise RuntimeError(f"Missing TRADIER_{MODE.upper()}_ACCOUNT_ID")

class TradierClient:
    def __init__(self):
        self.base_url   = BASE_URL
        self.token      = TOKEN
        self.account_id = ACCOUNT

    @property
    def headers(self) -> Dict[str, str]:
        return {
            "Authorization": f"Bearer {self.token}",
            "Accept":        "application/json",
        }

    async def get_expirations(self, symbol: str) -> List[str]:
        async with httpx.AsyncClient(base_url=self.base_url, headers=self.headers) as cli:
            r = await cli.get("/markets/options/expirations", params={"symbol": symbol})
            r.raise_for_status()
            return r.json().get("expirations", {}).get("date", [])

    async def get_quote(self, symbol: str) -> Dict[str, Any]:
        async with httpx.AsyncClient(base_url=self.base_url, headers=self.headers) as cli:
            r = await cli.get("/markets/quotes", params={"symbols": symbol})
            r.raise_for_status()
            return r.json().get("quotes", {}).get("quote", {})

    def format_tradier_option_symbol(self, ticker: str, expiration: str, right: str, strike: float) -> str:
        strike_str = f"{int(strike * 1000):08d}"
        return f"{ticker}{expiration}{right}{strike_str}"

    async def submit_multileg_order(
        self, symbol: str, legs: List[Dict[str, Any]], price: float = 1.0
    ) -> Dict[str, Any]:
        data = {
            "class":    "option",
            "type":     "multileg",
            "symbol":   symbol,
            "duration": "day",
            "price":    str(price),
        }
        for i, leg in enumerate(legs):
            data[f"option_symbol[{i}]"] = leg["option_symbol"]
            data[f"side[{i}]"]          = leg["side"]
            data[f"quantity[{i}]"]      = str(leg["quantity"])
        headers = {**self.headers, "Content-Type": "application/x-www-form-urlencoded"}
        async with httpx.AsyncClient(base_url=self.base_url, headers=headers) as cli:
            r = await cli.post(f"/accounts/{self.account_id}/orders", data=data)
            r.raise_for_status()
            return r.json()

    async def submit_equity_order(
        self, symbol: str, side: str, quantity: int, price: Optional[float] = None
    ) -> Dict[str, Any]:
        order_type = "market" if price is None else "limit"
        data = {
            "class":    "equity",
            "symbol":   symbol,
            "side":     side,
            "quantity": str(quantity),
            "duration": "day",
            "type":     order_type,
        }
        if price is not None:
            data["price"] = str(price)
        headers = {**self.headers, "Content-Type": "application/x-www-form-urlencoded"}
        async with httpx.AsyncClient(base_url=self.base_url, hea

